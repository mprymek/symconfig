# Proof of Concept of Logic-Based Configuration Management

*Inspired by Tommi Syrjänen's paper* A Rule-Based Formal Model For Software Configuration (1999)
*(http://www.tcs.hut.fi/old/reports/A55abstract.html)*

**This is just a proof of concept, do NOT use it for anything but entertainment!**

## Introduction

Symconfig has two main parts:
  1. expert system ("declarative part") inferes what state every configuration item of the system should be in
  2. actuator ("imperative part") communicates with the expert system, manipulates configured system state,
     generates managed files etc. (work in progress, not included here yet)

The basic principle of Symconfig is that every item in the system can be in *justified* (correct) or *unjustified*
(incorrect or unspecified) state.

The whole system should be (at least) in *acceptable state* - i.e. all *required items* (see `want/1` below)
and their prerequisites are in justified state.

*Perfect state* is acceptable state plus there are no items in unjustified state.

The expert system consists of:
  1. *universal rules* - the expert system itself
  2. *generated rules* - rules that are subject to change and are to be generated from some external
                         databases (like a database of available packages)
  3. *user-provided rules* - rules defining what functions user expects from the system
  4. *observation facts* - discovered facts about the configured system

Generated rules are: `latest(pkg(Name,Version))`, `pkg_depends(pkg(N,V),pkg(N,V))`, `file_meta(Origin,...)`,
`managed_file_src(Src,Dst)`, `managed_file_sha256(SrcSha,DstSha)`

User-provided rules are: `want(X)`, `depends(X,Y)`

## Example

The usage of the expert system is as follows:
  1. define the desired system's functions
  2. feed "generated rules" to the system
  3. iterively ask the system what you can do/verify to reach/assure the desired state

Let's suppose we are configuring a webserver. There must be an `nginx` service running
with modified configuration file `nginx.conf`. This modified file is derived from distribution file `nginx.conf-dist`.

One of the disadvantages of common configuration systems is that they
support configuration files templating but do not detect that
the distribution config file has changed upstream and hence the administrator should check if
the template is still correct or not. In the simplest case this could be semi-automated with
e.g. classic unix `patch` utility - if the patch applies cleanly, we suppose no manual intervention
is needed.

Symconfig determines the template correction is needed by relating distribution and templated files
sha checksums in `managed_file_sha256/2`. These rules are to be generated by the
templating engine (part of actuator, not included here yet).

So in our example situation we could have these generated rules:
```prolog
% latest version of nginx package
latest(pkg("nginx","1.6.2_1,2")).

% package dependencies
pkg_depends(pkg("nginx","1.6.2_1,2"),pkg("expat","2.1.0_2")).
pkg_depends(pkg("nginx","1.6.2_1,2"),pkg("openldap-sasl-client","2.4.40_1")).
pkg_depends(pkg("nginx","1.6.2_1,2"),pkg("pcre","8.35_2")).

% metadata of packages-provided files
file_meta(pkg("nginx","1.6.2_1,2"),"/usr/local/etc/nginx/nginx.conf-dist",file,0,0,644,[uarch],2693,"6418ea5b53e0c2b4e9baa517fce7ccf7619db03af68de7445dccb2c857978a4a").

% relations between distribution-provided configuration files and their templated versions
managed_file_src("/usr/local/etc/nginx/nginx.conf-dist","/usr/local/etc/nginx/nginx.conf").

% "deadbeaf" is of course not a valid sha256 checksum. It's given as just an example here...
managed_file_sha256("6418ea5b53e0c2b4e9baa517fce7ccf7619db03af68de7445dccb2c857978a4a","deadbeaf").
```

Let's define our server desired function (serving web pages):
```prolog
depends(running(svc("nginx")),installed(pkg("nginx"))).
depends(running(svc("nginx")),managed_file("/usr/local/etc/nginx/nginx.conf")).
% we can create templated config file only after nginx package has been installed
depends(managed_file("/usr/local/etc/nginx/nginx.conf"),installed(pkg("nginx"))).

% our core rule! :)
want(running(svc("nginx"))).
```

Now we can let Prolog infer what actions are to be taken to put our server into the desired state:
```prolog
?- consult('symconfig.pl').
true.

?- consult('example.pl').
true.

?- in_acceptable_state.
false.

?- to_achieve(acceptable_state,X).
X = verify(installed(pkg("nginx", "1.6.2_1,2"))).

%% ...actuator checks if nginx is installed or installs it...

?- assert(detected(installed(pkg("nginx", "1.6.2_1,2")))).
true.

?- in_acceptable_state.
false.

?- to_achieve(acceptable_state,X).
X = verify(sha256("/usr/local/etc/nginx/nginx.conf", "deadbeaf")).

%% the distribution config file has not changed - we know what checksum our templated
%% file should have.
%%
%% ...actuator checks if nginx.conf has the given sha...

?- assert(detected(sha256("/usr/local/etc/nginx/nginx.conf", "deadbeaf"))).
true.

?- to_achieve(acceptable_state,X).
X = verify(running(svc("nginx"))).

?- assert(detected(running(svc("nginx")))).
true.

?- to_achieve(acceptable_state,X).
false.

?- in_acceptable_state.
true.

?- in_perfect_state.
true.

%% Fifteen men on the dead man’s chest, yo ho ho, and a bottle of rum! 
```

We were told to install only `nginx` package and not its dependencies. That's because we suppose dependencies
are handled by the operating system's package manager. Still, we know that the prerequisite packages are justified:
```prolog
?- justified(installed(pkg("expat", "2.1.0_2"))).
true .
```

Now our server is in the perfect state. Let's pretend we have discovered some *extra* (not needed for it's function) file
on it:
```prolog
?- justified(sha256("/some/extra/file","cafeface")).
false.

?- assert(detected(sha256("/some/extra/file","cafeface"))).
true.

?- in_perfect_state.
false.

?- in_acceptable_state.
true.

?- retract(detected(sha256("/some/extra/file","cafeface"))).
true.

?- in_perfect_state.
true.
```

In a real world situation we must also be sure that the extra items do not impact desired server functions
(they are injustified but harmless) - e.g. we don't have unjustified configuration files which would
affect `nginx` functions. This function is not yet implemented.
